<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Subnet Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 90%;
            margin: 0 auto;
            padding: 10px;
            font-size: 0.75em; /* Reduce base font size to half */
        }
        .container {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
        }
        .form-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
        }
        input[type="text"], input[type="number"] {
            padding: 4px;
            width: 150px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
        }
        button {
            padding: 4px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        .checkboxes {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: #fff;
        }
        .checkbox-group {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .action-button {
            padding: 2px 6px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .action-button:hover {
            background-color: #0b7dda;
        }
        .hidden {
            display: none;
        }
        
        /* Join column styling to match default_subnets_subnets.html */
        .maskSpan {
            background-color: #cccccc;
            text-align: center;
            font-weight: bold;
        }
        
        .maskSpanJoinable {
            background-color: #cccccc;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
        }
        
        .maskSpanJoinable:hover {
            background-color: #bbbbbb;
        }
        
        .join-header {
            text-align: center;
            background-color: #f2f2f2;
        }
        
        h1, h2, h3 {
            font-size: 1.5em;
        }
        
        h3 {
            font-size: 1.2em;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Visual Subnet Calculator</h1>
        
        <div class="form-group">
            <label for="networkAddress">Network Address:</label>
            <input type="text" id="networkAddress" placeholder="e.g. 10.0.0.0">
        </div>
        
        <div class="form-group">
            <label for="maskBits">Mask bits:</label>
            <input type="number" id="maskBits" min="0" max="32" placeholder="e.g. 8">
        </div>
        
        <div class="form-group">
            <button id="generateBtn">Generate/Update</button>
            <button id="resetBtn">Reset</button>
        </div>
        
        <div class="checkboxes">
            <h3>Show columns:</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="showSubnetAddress">
                <label for="showSubnetAddress">Subnet address</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showNetmask">
                <label for="showNetmask">Netmask</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showRange">
                <label for="showRange">Range of addresses</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showUsableIPs">
                <label for="showUsableIPs">Usable IPs</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showAzureUsableIPs">
                <label for="showAzureUsableIPs">Azure Usable IPs</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showHosts">
                <label for="showHosts">Hosts</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showAzureHosts">
                <label for="showAzureHosts">Azure Hosts</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showDivide">
                <label for="showDivide">Divide</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showCollapse">
                <label for="showCollapse">Collapse</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showJoin">
                <label for="showJoin">Join</label>
            </div>
        </div>
        
        <div>
            <button id="exportBtn">Export to XLSX</button>
        </div>
        
        <div id="resultsContainer" class="hidden">
            <table id="resultsTable">
                <thead id="tableHeader">
                    <!-- Table headers will be dynamically generated -->
                </thead>
                <tbody id="tableBody">
                    <!-- Table rows will be dynamically generated -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- SheetJS library for XLSX export -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const networkAddressInput = document.getElementById('networkAddress');
            const maskBitsInput = document.getElementById('maskBits');
            const generateBtn = document.getElementById('generateBtn');
            const resetBtn = document.getElementById('resetBtn');
            const exportBtn = document.getElementById('exportBtn');
            const resultsContainer = document.getElementById('resultsContainer');
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');
            const checkboxes = document.querySelectorAll('.checkboxes input[type="checkbox"]');
            
            // Subnet data array to store calculated subnets
            let subnets = [];
            
            // Default values
            const defaultNetworkAddress = '10.0.0.0';
            const defaultMaskBits = 8;
            
            // Set default values
            networkAddressInput.value = defaultNetworkAddress;
            maskBitsInput.value = defaultMaskBits;
            
            // Check all checkboxes by default
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Event listeners
            generateBtn.addEventListener('click', generateSubnets);
            resetBtn.addEventListener('click', resetForm);
            exportBtn.addEventListener('click', exportToXLSX);
            
            // Add event listeners to all checkboxes to update the table when changed
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateTable);
            });
            
            // Functions
            function resetForm() {
                networkAddressInput.value = defaultNetworkAddress;
                maskBitsInput.value = defaultMaskBits;
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                resultsContainer.classList.add('hidden');
                subnets = [];
            }
            
            function generateSubnets() {
                const networkAddress = networkAddressInput.value;
                const maskBits = parseInt(maskBitsInput.value);
                
                // Validate inputs
                if (!isValidIPv4(networkAddress)) {
                    alert("Please enter a valid IPv4 address");
                    return;
                }
                
                if (isNaN(maskBits) || maskBits < 0 || maskBits > 32) {
                    alert("Mask bits must be between 0 and 32");
                    return;
                }
                
                // Calculate subnet information
                subnets = [calculateSubnet(networkAddress, maskBits)];
                
                // Update the table with the calculated subnet
                updateTable();
            }
            
            function isValidIPv4(ip) {
                const regex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
                return regex.test(ip);
            }
            
            function calculateSubnet(networkAddress, maskBits) {
                // Convert IP address to integer
                const ipInt = ipToInt(networkAddress);
                
                // Calculate subnet mask
                const mask = (0xffffffff >>> (32 - maskBits)) << (32 - maskBits);
                
                // Calculate network address (ensuring it's properly masked)
                const networkInt = ipInt & mask;
                const networkIP = intToIp(networkInt);
                
                // Calculate broadcast address
                const broadcastInt = networkInt | (~mask & 0xffffffff);
                const broadcastIP = intToIp(broadcastInt);
                
                // Calculate netmask in dotted decimal
                const netmaskIP = intToIp(mask);
                
                // Calculate number of hosts
                const hosts = Math.pow(2, 32 - maskBits) - 2;
                const azureHosts = hosts > 5 ? hosts - 5 : 0;
                
                // Calculate first and last usable IP
                const firstUsableInt = networkInt + 1;
                const lastUsableInt = broadcastInt - 1;
                
                const firstUsableIP = intToIp(firstUsableInt);
                const lastUsableIP = intToIp(lastUsableInt);
                
                // Calculate Azure usable IPs (excluding first 4 and last 1)
                const azureFirstUsableInt = networkInt + 4; // First 4 are reserved
                const azureLastUsableInt = broadcastInt - 1; // Last 1 is reserved
                
                let azureFirstUsableIP = '';
                let azureLastUsableIP = '';
                
                if (azureFirstUsableInt <= azureLastUsableInt) {
                    azureFirstUsableIP = intToIp(azureFirstUsableInt);
                    azureLastUsableIP = intToIp(azureLastUsableInt);
                }
                
                return {
                    networkAddress: networkIP,
                    maskBits: maskBits,
                    subnetAddress: `${networkIP}/${maskBits}`,
                    netmask: netmaskIP,
                    range: `${networkIP} - ${broadcastIP}`,
                    usableIPs: `${firstUsableIP} - ${lastUsableIP}`,
                    azureUsableIPs: azureFirstUsableInt <= azureLastUsableInt ? `${azureFirstUsableIP} - ${azureLastUsableIP}` : 'N/A',
                    hosts: hosts,
                    azureHosts: azureHosts,
                    networkInt: networkInt,
                    parents: [],  // Array to store all parent mask bits in hierarchy
                    childIndex: 0 // To track if it's the first or second child (0 or 1)
                };
            }
            
            function ipToInt(ip) {
                const parts = ip.split('.');
                return (parseInt(parts[0]) << 24) | 
                       (parseInt(parts[1]) << 16) | 
                       (parseInt(parts[2]) << 8) | 
                       parseInt(parts[3]);
            }
            
            function intToIp(int) {
                return [
                    (int >>> 24) & 255,
                    (int >>> 16) & 255,
                    (int >>> 8) & 255,
                    int & 255
                ].join('.');
            }
            
            function divideSubnet(index) {
                const subnet = subnets[index];
                
                // Can't divide /32 subnets
                if (subnet.maskBits >= 31) {
                    alert("Cannot divide a subnet with mask bits >= 31");
                    return;
                }
                
                // Calculate new mask bits (one more bit = divide by 2)
                const newMaskBits = subnet.maskBits + 1;
                
                // Create new parents array with current subnet added as parent
                const newParents = [...(subnet.parents || [])];
                newParents.push(subnet.maskBits);
                
                // Calculate first subnet
                const firstSubnet = calculateSubnet(subnet.networkAddress, newMaskBits);
                firstSubnet.parents = newParents;
                firstSubnet.childIndex = 0; // First child
                
                // Calculate second subnet
                const secondSubnetInt = subnet.networkInt + Math.pow(2, 32 - newMaskBits);
                const secondSubnetIP = intToIp(secondSubnetInt);
                const secondSubnet = calculateSubnet(secondSubnetIP, newMaskBits);
                secondSubnet.parents = newParents;
                secondSubnet.childIndex = 1; // Second child
                
                // Replace the original subnet with the two new ones
                subnets.splice(index, 1, firstSubnet, secondSubnet);
                
                // Update the table
                updateTable();
            }
            
            function collapseSubnets(index) {
                // Need at least two subnets to collapse
                if (subnets.length < 2 || index >= subnets.length - 1) {
                    alert("Cannot collapse this subnet (need a following subnet)");
                    return;
                }
                
                const subnet1 = subnets[index];
                const subnet2 = subnets[index + 1];
                
                // Check if they have the same mask bits
                if (subnet1.maskBits !== subnet2.maskBits) {
                    alert("Can only collapse subnets with the same mask bits");
                    return;
                }
                
                // Check if they're adjacent and can be collapsed
                const subnet1Size = Math.pow(2, 32 - subnet1.maskBits);
                
                if (subnet1.networkInt + subnet1Size !== subnet2.networkInt) {
                    alert("Subnets must be adjacent to collapse them");
                    return;
                }
                
                // Calculate the parent subnet
                const newMaskBits = subnet1.maskBits - 1;
                const collapsedSubnet = calculateSubnet(subnet1.networkAddress, newMaskBits);
                
                // If both subnets have the same parents and the last parent is one level up,
                // we should keep the parent hierarchy except for the last entry
                if (subnet1.parents.length > 0 && subnet2.parents.length > 0 && 
                    subnet1.parents.length === subnet2.parents.length) {
                    
                    // Check if all parents except the last one match
                    let parentsMatch = true;
                    for (let i = 0; i < subnet1.parents.length - 1; i++) {
                        if (subnet1.parents[i] !== subnet2.parents[i]) {
                            parentsMatch = false;
                            break;
                        }
                    }
                    
                    // If the last parent in both subnets is equal to newMaskBits, 
                    // and other parents match, we can keep all parents except the last one
                    if (parentsMatch && subnet1.parents[subnet1.parents.length - 1] === newMaskBits) {
                        collapsedSubnet.parents = subnet1.parents.slice(0, -1);
                        collapsedSubnet.childIndex = subnet1.childIndex; // Inherit child index
                    }
                }
                
                // Replace the two subnets with the collapsed one
                subnets.splice(index, 2, collapsedSubnet);
                
                // Update the table
                updateTable();
            }
            
            // Find all children of a subnet that has been divided
            function findChildSubnets(parentIndex) {
                const result = [];
                const parentSubnet = subnets[parentIndex];
                const parentMaskBits = parentSubnet.maskBits;
                
                // Group subnets by their common parent mask bits
                for (let i = 0; i < subnets.length; i++) {
                    if (i !== parentIndex) {
                        const subnet = subnets[i];
                        // Check if this subnet has the parent as one of its parents
                        if (subnet.parents && subnet.parents.includes(parentMaskBits)) {
                            // Make sure this is a direct child of the parent (should have the next mask bit level)
                            const parentIndex = subnet.parents.indexOf(parentMaskBits);
                            if (parentIndex === subnet.parents.length - 1) {
                                result.push(i);
                            }
                        }
                    }
                }
                
                return result;
            }
            
            // Function to collapse a subnet at a specific parent level
            function joinSubnet(index, parentMaskBits) {
                // Find all subnets that share this parent
                const subnetIndicesToRemove = [];
                let lowestIndex = Number.MAX_SAFE_INTEGER;
                let parentNetworkAddress;
                
                for (let i = 0; i < subnets.length; i++) {
                    const subnet = subnets[i];
                    if (subnet.parents && subnet.parents.includes(parentMaskBits)) {
                        subnetIndicesToRemove.push(i);
                        if (i < lowestIndex) {
                            lowestIndex = i;
                            // Get the network address of the parent by masking any child
                            parentNetworkAddress = network_address(subnet.networkInt, parentMaskBits);
                        }
                    }
                }
                
                if (subnetIndicesToRemove.length === 0) {
                    return; // Nothing to join
                }
                
                // Create the parent subnet
                const parentSubnet = calculateSubnet(intToIp(parentNetworkAddress), parentMaskBits);
                
                // Keep parents that are higher in the hierarchy
                const subnet = subnets[subnetIndicesToRemove[0]];
                const parentIndex = subnet.parents.indexOf(parentMaskBits);
                if (parentIndex > 0) {
                    parentSubnet.parents = subnet.parents.slice(0, parentIndex);
                    parentSubnet.childIndex = subnet.childIndex; // Inherit child index
                }
                
                // Remove all child subnets
                // Sort indices in descending order to avoid shifting problems
                subnetIndicesToRemove.sort((a, b) => b - a);
                for (const idx of subnetIndicesToRemove) {
                    subnets.splice(idx, 1);
                }
                
                // Insert the parent subnet
                subnets.splice(lowestIndex, 0, parentSubnet);
                
                // Update the table
                updateTable();
            }
            
            // Helper function for network_address calculation
            function network_address(ipInt, maskBits) {
                const mask = (0xffffffff >>> (32 - maskBits)) << (32 - maskBits);
                return ipInt & mask;
            }
            
            function updateTable() {
                // If no subnets or no checkboxes selected, hide the table
                if (subnets.length === 0 || !Array.from(checkboxes).some(cb => cb.checked)) {
                    resultsContainer.classList.add('hidden');
                    return;
                }
                
                // Show the results container
                resultsContainer.classList.remove('hidden');
                
                // Organize parent-child relationships for display
                const parentChildMap = new Map();
                
                // First find all unique parent masks and sort them
                const allParentMasks = new Set();
                subnets.forEach(subnet => {
                    if (subnet.parents && subnet.parents.length > 0) {
                        subnet.parents.forEach(parent => {
                            allParentMasks.add(parent);
                        });
                    }
                });
                
                // Convert to array and sort in DESCENDING order (largest to smallest)
                const sortedParentMasks = Array.from(allParentMasks).sort((a, b) => b - a);
                
                // Create table headers based on selected checkboxes
                let headerRow = '<tr><th>#</th>';
                
                if (document.getElementById('showSubnetAddress').checked)
                    headerRow += '<th>Subnet Address</th>';
                if (document.getElementById('showNetmask').checked)
                    headerRow += '<th>Netmask</th>';
                if (document.getElementById('showRange').checked)
                    headerRow += '<th>Range of Addresses</th>';
                if (document.getElementById('showUsableIPs').checked)
                    headerRow += '<th>Usable IPs</th>';
                if (document.getElementById('showAzureUsableIPs').checked)
                    headerRow += '<th>Azure Usable IPs</th>';
                if (document.getElementById('showHosts').checked)
                    headerRow += '<th>Hosts</th>';
                if (document.getElementById('showAzureHosts').checked)
                    headerRow += '<th>Azure Hosts</th>';
                if (document.getElementById('showDivide').checked)
                    headerRow += '<th>Divide</th>';
                if (document.getElementById('showCollapse').checked)
                    headerRow += '<th>Collapse</th>';
                
                // Add "Join" column header with correct colspan
                if (document.getElementById('showJoin').checked) {
                    // +1 for the current subnet mask column
                    const joinColspan = sortedParentMasks.length + 1;
                    headerRow += `<th class="join-header" colspan="${joinColspan}">Join</th>`;
                }
                
                headerRow += '</tr>';
                tableHeader.innerHTML = headerRow;
                
                // For each subnet, organize the mask info for display
                subnets.forEach(subnet => {
                    // Create a map of parent masks to their positions in the sorted array
                    const maskPositions = new Map();
                    if (subnet.parents && subnet.parents.length > 0) {
                        subnet.parents.forEach(parent => {
                            const position = sortedParentMasks.indexOf(parent);
                            maskPositions.set(parent, position);
                        });
                    }
                    subnet.maskPositions = maskPositions;
                });
                
                // Calculate rowspans for each parent mask across all subnets
                const maskRowspans = new Map();
                
                for (const parentMask of sortedParentMasks) {
                    // Group subnets by the same parent mask at each position
                    const groupsByPosition = new Map();
                    
                    // First pass - identify all positions where this parent mask appears
                    subnets.forEach((subnet, index) => {
                        if (subnet.parents && subnet.parents.includes(parentMask)) {
                            const position = subnet.maskPositions.get(parentMask);
                            if (!groupsByPosition.has(position)) {
                                groupsByPosition.set(position, []);
                            }
                            groupsByPosition.get(position).push(index);
                        }
                    });
                    
                    // Second pass - identify consecutive groups for rowspans
                    for (const [position, indices] of groupsByPosition.entries()) {
                        let currentGroup = [];
                        for (let i = 0; i < indices.length; i++) {
                            const index = indices[i];
                            
                            if (currentGroup.length === 0 || indices[i] === indices[i-1] + 1) {
                                // Continue current group
                                currentGroup.push(index);
                            } else {
                                // Start a new group
                                maskRowspans.set(`${parentMask}-${position}-${currentGroup[0]}`, currentGroup.length);
                                currentGroup = [index];
                            }
                        }
                        
                        // Don't forget the last group
                        if (currentGroup.length > 0) {
                            maskRowspans.set(`${parentMask}-${position}-${currentGroup[0]}`, currentGroup.length);
                        }
                    }
                }
                
                // Create table rows with subnet data
                let tableRows = '';
                
                // Keep track of which cells we've already output via rowspan
                const cellsOutput = new Set();
                
                subnets.forEach((subnet, index) => {
                    tableRows += `<tr>`;
                    tableRows += `<td>${index + 1}</td>`;
                    
                    // Add standard columns
                    if (document.getElementById('showSubnetAddress').checked)
                        tableRows += `<td>${subnet.subnetAddress}</td>`;
                    if (document.getElementById('showNetmask').checked)
                        tableRows += `<td>${subnet.netmask}</td>`;
                    if (document.getElementById('showRange').checked)
                        tableRows += `<td>${subnet.range}</td>`;
                    if (document.getElementById('showUsableIPs').checked)
                        tableRows += `<td>${subnet.usableIPs}</td>`;
                    if (document.getElementById('showAzureUsableIPs').checked)
                        tableRows += `<td>${subnet.azureUsableIPs}</td>`;
                    if (document.getElementById('showHosts').checked)
                        tableRows += `<td>${subnet.hosts.toLocaleString()}</td>`;
                    if (document.getElementById('showAzureHosts').checked)
                        tableRows += `<td>${subnet.azureHosts.toLocaleString()}</td>`;
                    if (document.getElementById('showDivide').checked)
                        tableRows += `<td><button class="action-button" onclick="window.divideSubnet(${index})">Divide</button></td>`;
                    if (document.getElementById('showCollapse').checked)
                        tableRows += `<td><button class="action-button" onclick="window.collapseSubnets(${index})">Collapse</button></td>`;
                    
                    // Add Join columns with current subnet FIRST, then parent columns
                    if (document.getElementById('showJoin').checked) {
                        // Always add current subnet mask as the FIRST column
                        tableRows += `<td class="maskSpan">/${subnet.maskBits}</td>`;
                        
                        // For each possible parent mask position (in DESCENDING order)
                        for (let i = 0; i < sortedParentMasks.length; i++) {
                            const parentMask = sortedParentMasks[i];
                            
                            // Check if this subnet has this parent mask
                            if (subnet.parents && subnet.parents.includes(parentMask)) {
                                // Check if we've already output this cell (due to rowspan)
                                const cellKey = `${parentMask}-${i}-${index}`;
                                
                                if (!cellsOutput.has(cellKey)) {
                                    // Calculate rowspan
                                    const rowspan = maskRowspans.get(cellKey) || 1;
                                    
                                    // Output the cell
                                    tableRows += `<td class="maskSpanJoinable" rowspan="${rowspan}" 
                                        onclick="window.joinSubnet(${index}, ${parentMask})">/${parentMask}</td>`;
                                    
                                    // Mark as output
                                    cellsOutput.add(cellKey);
                                    
                                    // Also mark subsequent rows that are covered by this rowspan
                                    for (let j = 1; j < rowspan; j++) {
                                        cellsOutput.add(`${parentMask}-${i}-${index + j}`);
                                    }
                                }
                            } else {
                                // This subnet doesn't have this parent mask - add empty cell if needed
                                const cellKey = `empty-${i}-${index}`;
                                
                                if (!cellsOutput.has(cellKey)) {
                                    tableRows += `<td></td>`;
                                    cellsOutput.add(cellKey);
                                }
                            }
                        }
                    }
                    
                    tableRows += '</tr>';
                });
                
                tableBody.innerHTML = tableRows;
            }
            
            // Helper function to calculate rowspan for a parent cell
            function calculateParentRowspan(subnet, parentIndex) {
                const parentMask = subnet.parents[parentIndex];
                
                // Count how many subnets share this parent at the same level
                let count = 0;
                for (const s of subnets) {
                    if (s.parents && 
                        s.parents.length > parentIndex && 
                        s.parents[parentIndex] === parentMask) {
                        count++;
                    }
                }
                
                return count;
            }
            
            function exportToXLSX() {
                if (subnets.length === 0) {
                    alert("No data to export");
                    return;
                }
                
                // Create worksheet data
                const ws_data = [];
                
                // Add header row
                const header = ['#'];
                
                if (document.getElementById('showSubnetAddress').checked)
                    header.push('Subnet Address');
                if (document.getElementById('showNetmask').checked)
                    header.push('Netmask');
                if (document.getElementById('showRange').checked)
                    header.push('Range of Addresses');
                if (document.getElementById('showUsableIPs').checked)
                    header.push('Usable IPs');
                if (document.getElementById('showAzureUsableIPs').checked)
                    header.push('Azure Usable IPs');
                if (document.getElementById('showHosts').checked)
                    header.push('Hosts');
                if (document.getElementById('showAzureHosts').checked)
                    header.push('Azure Hosts');
                
                // Add Join column(s)
                if (document.getElementById('showJoin').checked) {
                    // Find all unique parent masks and sort them
                    const allParentMasks = new Set();
                    subnets.forEach(subnet => {
                        if (subnet.parents && subnet.parents.length > 0) {
                            subnet.parents.forEach(parent => {
                                allParentMasks.add(parent);
                            });
                        }
                    });
                    
                    // Convert to array and sort in DESCENDING order (largest to smallest)
                    const sortedParentMasks = Array.from(allParentMasks).sort((a, b) => b - a);
                    
                    // Add header for current mask FIRST
                    header.push('Current Mask');
                    
                    // Add headers for each parent mask level
                    for (const parentMask of sortedParentMasks) {
                        header.push(`Parent /${parentMask}`);
                    }
                }
                
                ws_data.push(header);
                
                // Add data rows
                subnets.forEach((subnet, index) => {
                    const row = [index + 1];
                    
                    if (document.getElementById('showSubnetAddress').checked)
                        row.push(subnet.subnetAddress);
                    if (document.getElementById('showNetmask').checked)
                        row.push(subnet.netmask);
                    if (document.getElementById('showRange').checked)
                        row.push(subnet.range);
                    if (document.getElementById('showUsableIPs').checked)
                        row.push(subnet.usableIPs);
                    if (document.getElementById('showAzureUsableIPs').checked)
                        row.push(subnet.azureUsableIPs);
                    if (document.getElementById('showHosts').checked)
                        row.push(subnet.hosts);
                    if (document.getElementById('showAzureHosts').checked)
                        row.push(subnet.azureHosts);
                    
                    // Add Join data with current mask first
                    if (document.getElementById('showJoin').checked) {
                        // Find all unique parent masks and sort them
                        const allParentMasks = new Set();
                        subnets.forEach(s => {
                            if (s.parents && s.parents.length > 0) {
                                s.parents.forEach(parent => {
                                    allParentMasks.add(parent);
                                });
                            }
                        });
                        
                        // Convert to array and sort in DESCENDING order (largest to smallest)
                        const sortedParentMasks = Array.from(allParentMasks).sort((a, b) => b - a);
                        
                        // Add current mask FIRST
                        row.push(`/${subnet.maskBits}`);
                        
                        // For each parent mask, add value if this subnet has it
                        for (const parentMask of sortedParentMasks) {
                            if (subnet.parents && subnet.parents.includes(parentMask)) {
                                row.push(`/${parentMask}`);
                            } else {
                                row.push('');
                            }
                        }
                    }
                    
                    ws_data.push(row);
                });
                
                // Create workbook and worksheet
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(ws_data);
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, "Subnet Calculations");
                
                // Generate filename with timestamp
                const now = new Date();
                const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
                const filename = `subnet_calculations_${timestamp}.xlsx`;
                
                // Export to file
                XLSX.writeFile(wb, filename);
            }
            
            // Expose these functions to the global scope so they can be called from HTML
            window.divideSubnet = divideSubnet;
            window.collapseSubnets = collapseSubnets;
            window.joinSubnet = joinSubnet;
    });
    </script>
</body>
</html>